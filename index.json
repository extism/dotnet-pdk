{
  "README.html": {
    "href": "README.html",
    "title": ".NET PDK | Extism .NET PDK",
    "keywords": ".NET PDK This library can be used to write Extism Plug-ins in C# and F#. NOTE: This is an experimental PDK. We'd love to hear your feedback. Prerequisites .NET SDK 8: https://dotnet.microsoft.com/en-us/download/dotnet/8.0 WASI Workload: dotnet workload install wasi-experimental WASI SDK: https://github.com/WebAssembly/wasi-sdk/releases Install Create a new project and add this nuget package to your project: dotnet new wasiconsole -o MyPlugin # OR, for F#: dotnet new console -o MyPlugin -lang F# cd MyPlugin dotnet add package Extism.Pdk --prerelease Update your MyPlugin.csproj/MyPlugin.fsproj as follows: <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier> <OutputType>Exe</OutputType> <PublishTrimmed>true</PublishTrimmed> <!-- Make sure we create a standalone wasm file for our plugin --> <WasmSingleFileBundle>true</WasmSingleFileBundle> <WasmBuildNative>true</WasmBuildNative> </PropertyGroup> </Project> Getting Started The goal of writing an Extism plug-in is to compile your C#/F# code to a Wasm module with exported functions that the host application can invoke. The first thing you should understand is creating an export. Let's write a simple program that exports a greet function which will take a name as a string and return a greeting string. Paste this into your Program.cs/Program.fs: C#: using System; using System.Runtime.InteropServices; using System.Text.Json; using Extism; namespace MyPlugin; public class Functions { public static void Main() { // Note: a `Main` method is required for the app to compile } [UnmanagedCallersOnly(EntryPoint = \"greet\")] public static int Greet() { var name = Pdk.GetInputString(); var greeting = $\"Hello, {name}!\"; Pdk.SetOutput(greeting); return 0; } } F#: module MyPlugin open System open System.Runtime.InteropServices open System.Text.Json open Extism [<UnmanagedCallersOnly(EntryPoint = \"greet\")>] let Greet () : int32 = let name = Pdk.GetInputString() let greeting = $\"Hello, {name}!\" Pdk.SetOutput(greeting) 0 [<EntryPoint>] let Main args = // Note: an `EntryPoint` function is required for the app to compile 0 Some things to note about this code: The [UnmanagedCallersOnly(EntryPoint = \"greet\")] is required, this marks the Greet function as an export with the name greet that can be called by the host. EntryPoint is optional. We need a Main but it's unused. If you do want to use it, it's exported as a function called _start. Exports in the .NET PDK are coded to the raw ABI. You get parameters from the host by calling Pdk.GetInput* functions and you send returns back with the Pdk.SetOutput functions. An Extism export expects an Int32 return code. 0 is success and 1 is a failure. Compile with this command: dotnet build This will create a MyPlugin.wasm file in bin/Debug/net8.0/wasi-wasm/AppBundle. Now, you can try out your plugin by using any of the Extism SDKs or by using Extism CLI's run command: extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm greet --input \"Benjamin\" --wasi # => Hello, Benjamin! Note: Currently wasi must be provided for all .NET plug-ins even if they don't need system access. More Exports: Error Handling Suppose we want to re-write our greeting function to never greet Benjamis. We can use Pdk.SetError: C#: [UnmanagedCallersOnly(EntryPoint = \"greet\")] public static int Greet() { var name = Pdk.GetInputString(); if (name == \"Benjamin\") { Pdk.SetError(\"Sorry, we don't greet Benjamins!\"); return 1; } var greeting = $\"Hello, {name}!\"; Pdk.SetOutput(greeting); return 0; } F#: [<UnmanagedCallersOnly(EntryPoint = \"greet\")>] let Greet () = let name = Pdk.GetInputString() if name = \"Benjamin\" then Pdk.SetError(\"Sorry, we don't greet Benjamins!\") 1 else let greeting = $\"Hello, {name}!\" Pdk.SetOutput(greeting) 0 Now when we try again: extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm greet --input=\"Benjamin\" --wasi # => Error: Sorry, we don't greet Benjamins! echo $? # print last status code # => 1 extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm greet --input=\"Zach\" --wasi # => Hello, Zach! echo $? # => 0 We can also throw a normal .NET Exception: var name = Pdk.GetInputString(); if (name == \"Benjamin\") { throw new ArgumentException(\"Sorry, we don't greet Benjamins!\"); } Now when we try again: extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm greet --input=\"Benjamin\" --wasi # => Error: System.ArgumentException: Sorry, we don't greet Benjamins! at MyPlugin.Functions.Greet() Json Extism export functions simply take bytes in and bytes out. Those can be whatever you want them to be. A common and simple way to get more complex types to and from the host is with json: C#: [JsonSerializable(typeof(Add))] [JsonSerializable(typeof(Sum))] public partial class SourceGenerationContext : JsonSerializerContext {} public record Add(int a, int b); public record Sum(int Result); public static class Functions { [UnmanagedCallersOnly] public static int add() { var inputJson = Pdk.GetInputString(); var parameters = JsonSerializer.Deserialize(inputJson, SourceGenerationContext.Default.Add); var sum = new Sum(parameters.a + parameters.b); var outputJson = JsonSerializer.Serialize(sum, SourceGenerationContext.Default.Sum); Pdk.SetOutput(outputJson); return 0; } } F#: [<UnmanagedCallersOnly>] let add () = let inputJson = Pdk.GetInputString() let jsonData = JsonDocument.Parse(inputJson).RootElement let a = jsonData.GetProperty(\"a\").GetInt32() let b = jsonData.GetProperty(\"b\").GetInt32() let result = a + b let outputJson = $\"{{ \\\"Result\\\": {result} }}\" Pdk.SetOutput(outputJson) 0 Note: For F#, please make sure the System.Text.Json NuGet package is installed in your project. extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm --wasi add --input='{\"a\": 20, \"b\": 21}' # => {\"Result\":41} Note: When enabling trimming, make sure you use the source generation as reflection is disabled in that mode. Configs Configs are key-value pairs that can be passed in by the host when creating a plug-in. These can be useful to statically configure the plug-in with some data that exists across every function call. Here is a trivial example using Pdk.TryGetConfig: C#: [UnmanagedCallersOnly(EntryPoint = \"greet\")] public static int Greet() { if (!Pdk.TryGetConfig(\"user\", out var user)) { throw new InvalidOperationException(\"This plug-in requires a 'user' key in the config\"); } var greeting = $\"Hello, {user}!\"; Pdk.SetOutput(greeting); return 0; } F#: [<UnmanagedCallersOnly(EntryPoint = \"greet\")>] let Greet () = match Pdk.TryGetConfig \"user\" with | true, user -> let greeting = $\"Hello, {user}!\" Pdk.SetOutput(greeting) 0 | false, _ -> failwith \"This plug-in requires a 'user' key in the config\" To test it, the Extism CLI has a --config option that lets you pass in key=value pairs: extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm --wasi greet --config user=Benjamin # => Hello, Benjamin! Variables Variables are another key-value mechanism but it's a mutable data store that will persist across function calls. These variables will persist as long as the host has loaded and not freed the plug-in. C#: [UnmanagedCallersOnly] public static int count() { int count = 0; if (Pdk.TryGetVar(\"count\", out var memoryBlock)) { count = BitConverter.ToInt32(memoryBlock.ReadBytes()); } count += 1; Pdk.SetVar(\"count\", BitConverter.GetBytes(count)); Pdk.SetOutput(count.ToString()); return 0; } F#: [<UnmanagedCallersOnly>] let count () = let count = match Pdk.TryGetVar \"count\" with | true, buffer -> BitConverter.ToInt32(buffer.ReadBytes()) | false, _ -> 0 let count = count + 1 Pdk.SetVar(\"count\", BitConverter.GetBytes(count)) Pdk.SetOutput(count.ToString()) 0 From Extism CLI: extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm --wasi count --loop 3 1 2 3 HTTP Sometimes it is useful to let a plug-in make HTTP calls: C#: [UnmanagedCallersOnly] public static int http_get() { // create an HTTP Request (withuot relying on WASI), set headers as needed var request = new HttpRequest(\"https://jsonplaceholder.typicode.com/todos/1\") { Method = HttpMethod.GET, }; request.Headers.Add(\"some-name\", \"some-value\"); request.Headers.Add(\"another\", \"again\"); var response = Pdk.SendRequest(request); Pdk.SetOutput(response.Body); return 0; } F#: [<UnmanagedCallersOnly>] let http_get () = let request = HttpRequest(\"https://jsonplaceholder.typicode.com/todos/1\") request.Headers.Add(\"some-name\", \"some-value\") request.Headers.Add(\"another\", \"again\") let response = Pdk.SendRequest(request) Pdk.SetOutput(response.Body) 0 From Extism CLI: extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm --wasi http_get --allow-host='*.typicode.com' { \"userId\": 1, \"id\": 1, \"title\": \"delectus aut autem\", \"completed\": false } NOTE: HttpClient doesn't work in Wasm yet. Imports (Host Functions) Like any other code module, Wasm not only let's you export functions to the outside world, you can import them too. Host Functions allow a plug-in to import functions defined in the host. For example, if you host application is written in Go, it can pass a Go function down to your Go plug-in where you can invoke it. This topic can get fairly complicated and we have not yet fully abstracted the Wasm knowledge you need to do this correctly. So we recommend reading our concept doc on Host Functions before you get started. A Simple Example Host functions have a similar interface as exports. You just need to declare them as extern on the top of your Program.cs/Program.fs. You only declare the interface as it is the host's responsibility to provide the implementation: C#: [DllImport(\"extism\", EntryPoint = \"a_go_func\")] public static extern ulong GoFunc(ulong offset); [UnmanagedCallersOnly] public static int hello_from_go() { var message = \"An argument to send to Go\"; using var block = Pdk.Allocate(message); var ptr = GoFunc(block.Offset); var response = MemoryBlock.Find(ptr).ReadString(); Pdk.SetOutput(response); return 0; } F#: [<DllImport(\"extism\", EntryPoint = \"a_go_func\")>] extern uint64 GoFunc(uint64 offset) [<UnmanagedCallersOnly>] let hello_from_go () = let message = \"An argument to send to Go\" use block = Pdk.Allocate(message) let ptr = GoFunc(block.Offset) let response = MemoryBlock.Find ptr Pdk.SetOutput(response) 0 Testing it out We can't really test this from the Extism CLI as something must provide the implementation. So let's write out the Go side here. Check out the docs for Host SDKs to implement a host function in a language of your choice. ctx := context.Background() config := extism.PluginConfig{ EnableWasi: true, } go_func := extism.NewHostFunctionWithStack( \"a_go_func\", func(ctx context.Context, p *extism.CurrentPlugin, stack []uint64) { input, err := p.ReadString(stack[0]) if err != nil { panic(err) } fmt.Println(\"Hello from Go!\") offs, err := p.WriteString(input + \"!\") if err != nil { panic(err) } stack[0] = offs }, []api.ValueType{api.ValueTypeI64}, []api.ValueType{api.ValueTypeI64}, ) Now when we load the plug-in we pass the host function: manifest := extism.Manifest{ Wasm: []extism.Wasm{ extism.WasmFile{ Path: \"/path/to/plugin.wasm\", }, }, } plugin, err := extism.NewPlugin(ctx, manifest, config, []extism.HostFunction{go_func}) if err != nil { fmt.Printf(\"Failed to initialize plugin: %v\\n\", err) os.Exit(1) } _, out, err := plugin.Call(\"hello_from_go\", []byte(\"Hello, World!\")) fmt.Println(string(out)) go run . # => Hello from Go! # => An argument to send to Go! Referenced Assemblies Methods in referenced assemblies that are decorated with [DllImport] and [UnmanagedCallersOnly] are imported and exported respectively. Note: The library imports/exports are ignored if the app doesn't call at least one method from the library. For example, if we have a library that contains this class: namespace MessagingBot.Pdk; public class Events { // This function will be imported by all WASI apps that reference this library [DllImport(\"env\", EntryPoint = \"send_message\")] public static extern void SendMessage(ulong offset); // You can wrap the imports in your own functions to make them easier to use public static void SendMessage(string message) { using var block = Extism.Pdk.Allocate(message); SendMessage(block.Offset); } // This function will be exported by all WASI apps that reference this library [UnmanagedCallersOnly] public static void message_received() { var message = Extism.Pdk.GetInputString(); // TODO: do stuff with message } } Then, we can reference the library in a WASI app and use the functions: using MessagingBot.Pdk; Events.SendMessage(\"Hello World!\"); This is useful when you want to provide a common set of imports and exports that are specific to your use case. Optimize Size Normally, the .NET runtime is very conservative when trimming and includes a lot of metadata for debugging and exception purposes. This makes sure code doesn't break (when using reflection for example) but it also means large binary sizes. A hello world sample is about 20mb. To instruct the .NET compiler to be aggresive about trimming, you can try out these options: <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier> <OutputType>Exe</OutputType> <PublishTrimmed>true</PublishTrimmed> <WasmBuildNative>true</WasmBuildNative> <WasmSingleFileBundle>true</WasmSingleFileBundle> <!-- Note: TrimMode Full breaks Extism's global exception handling hook --> <TrimMode>partial</TrimMode> <DebuggerSupport>false</DebuggerSupport> <EventSourceSupport>false</EventSourceSupport> <UseSystemResourceKeys>true</UseSystemResourceKeys> <NativeDebugSymbols>false</NativeDebugSymbols> </PropertyGroup> </Project> If you have imports in referenced assemblies, make sure you mark them as roots so that they don't get trimmed: <ItemGroup> <TrimmerRootAssembly Include=\"SampleLib\" /> </ItemGroup> And then, run: dotnet publish -c Release Now, you'll have a significantly smaller .wasm file in bin\\Release\\net8.0\\wasi-wasm\\AppBundle. For more details, refer to the official documentation. Reach Out! Have a question or just want to drop in and say hi? Hop on the Discord!"
  },
  "api/Extism.HttpMethod.html": {
    "href": "api/Extism.HttpMethod.html",
    "title": "Enum HttpMethod | Extism .NET PDK",
    "keywords": "Enum HttpMethod Namespace Extism Assembly Extism.Pdk.dll HTTP Method public enum HttpMethod Fields DELETE = 3 DELETE GET = 0 GET HEAD = 4 HEAD PATCH = 5 PATCH POST = 1 POST PUT = 2 PUT"
  },
  "api/Extism.HttpRequest.html": {
    "href": "api/Extism.HttpRequest.html",
    "title": "Class HttpRequest | Extism .NET PDK",
    "keywords": "Class HttpRequest Namespace Extism Assembly Extism.Pdk.dll An HTTP request public class HttpRequest Inheritance object HttpRequest Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HttpRequest(string) public HttpRequest(string url) Parameters url string HttpRequest(Uri) public HttpRequest(Uri url) Parameters url Uri Properties Body An optional body. public byte[] Body { get; set; } Property Value byte[] Headers HTTP Headers public Dictionary<string, string> Headers { get; } Property Value Dictionary<string, string> Method HTTP method public HttpMethod Method { get; set; } Property Value HttpMethod Url HTTP URL public Uri Url { get; set; } Property Value Uri"
  },
  "api/Extism.HttpResponse.html": {
    "href": "api/Extism.HttpResponse.html",
    "title": "Class HttpResponse | Extism .NET PDK",
    "keywords": "Class HttpResponse Namespace Extism Assembly Extism.Pdk.dll Response from an HTTP call public class HttpResponse : IDisposable Inheritance object HttpResponse Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HttpResponse(MemoryBlock, ushort) public HttpResponse(MemoryBlock memory, ushort status) Parameters memory MemoryBlock status ushort Properties Body Body of the HTTP response public MemoryBlock Body { get; } Property Value MemoryBlock Status HTTP Status Code public ushort Status { get; set; } Property Value ushort Methods Dispose() Frees the current memory block. public void Dispose()"
  },
  "api/Extism.LogLevel.html": {
    "href": "api/Extism.LogLevel.html",
    "title": "Enum LogLevel | Extism .NET PDK",
    "keywords": "Enum LogLevel Namespace Extism Assembly Extism.Pdk.dll Log level public enum LogLevel Fields Debug = 1 Debug Error = 3 Error Info = 0 Information Warn = 2 Warning"
  },
  "api/Extism.MemoryBlock.html": {
    "href": "api/Extism.MemoryBlock.html",
    "title": "Class MemoryBlock | Extism .NET PDK",
    "keywords": "Class MemoryBlock Namespace Extism Assembly Extism.Pdk.dll A block of allocated memory. public class MemoryBlock : IDisposable Inheritance object MemoryBlock Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MemoryBlock(ulong, ulong) public MemoryBlock(ulong offset, ulong length) Parameters offset ulong length ulong Properties Empty An Empty memory block. public static MemoryBlock Empty { get; } Property Value MemoryBlock IsEmpty Is block empty. public bool IsEmpty { get; } Property Value bool Length Length of block in bytes public ulong Length { get; } Property Value ulong Offset Starts address of block public ulong Offset { get; } Property Value ulong Methods CopyTo(Span<byte>) Copies the contents of a memory block into a buffer. public void CopyTo(Span<byte> buffer) Parameters buffer Span<byte> Exceptions InvalidOperationException Dispose() Frees the current memory block. public void Dispose() Find(ulong) Finds a memory block based on its start address. public static MemoryBlock Find(ulong offset) Parameters offset ulong Returns MemoryBlock ReadBytes() Reads the current memory block as a byte array. public byte[] ReadBytes() Returns byte[] ReadString() Reads the current memory block as a UTF8 encoded string. public string ReadString() Returns string WriteBytes(ReadOnlySpan<byte>) Writes a byte buffer to this memory block. public void WriteBytes(ReadOnlySpan<byte> bytes) Parameters bytes ReadOnlySpan<byte> Exceptions IndexOutOfRangeException WriteString(string) Writes a string to the current memory block. public void WriteString(string text) Parameters text string"
  },
  "api/Extism.Pdk.html": {
    "href": "api/Extism.Pdk.html",
    "title": "Class Pdk | Extism .NET PDK",
    "keywords": "Class Pdk Namespace Extism Assembly Extism.Pdk.dll Provides interop functions for communication between guests and the host. public static class Pdk Inheritance object Pdk Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Allocate(ReadOnlySpan<byte>) Allocate a byte buffer into memory. public static MemoryBlock Allocate(ReadOnlySpan<byte> buffer) Parameters buffer ReadOnlySpan<byte> The byte buffer to allocate into memory. Returns MemoryBlock A MemoryBlock instance representing the allocated memory. Allocate(string) Encodes a string as UTF-8 and stores it in memory. public static MemoryBlock Allocate(string data) Parameters data string The string to allocate into memory. Returns MemoryBlock A MemoryBlock instance representing the allocated memory. Allocate(ulong) Allocate a block of memory with the specified length. public static MemoryBlock Allocate(ulong length) Parameters length ulong The size of the memory block in bytes. Returns MemoryBlock A MemoryBlock instance representing the allocated memory. GetInput() Read the input data sent by the host. public static byte[] GetInput() Returns byte[] The input data as a byte array. GetInputString() Read the input data sent by the host as a UTF-8 encoded string. public static string GetInputString() Returns string Log(LogLevel, MemoryBlock) Log a message with the specified log level to the host. public static void Log(LogLevel level, MemoryBlock block) Parameters level LogLevel The log level for the message. block MemoryBlock The memory block containing the log message. Log(LogLevel, string) Logs a message to the host. public static void Log(LogLevel level, string message) Parameters level LogLevel message string RemoveVar(string) Remove a variable from host memory. public static void RemoveVar(string key) Parameters key string The key of the variable to remove. SendRequest(HttpRequest) Send an HTTP request synchronously and get the response from the host. public static HttpResponse SendRequest(HttpRequest request) Parameters request HttpRequest The HTTP request to send. Returns HttpResponse The HTTP response received from the host. SetError(string) Set plugin error public static void SetError(string errorMessage) Parameters errorMessage string SetOutput(MemoryBlock) Set the output data to be sent back to the host. public static void SetOutput(MemoryBlock block) Parameters block MemoryBlock The memory block containing the output data. SetOutput(ReadOnlySpan<byte>) Set the output data to be sent back to the host as a byte buffer. public static void SetOutput(ReadOnlySpan<byte> data) Parameters data ReadOnlySpan<byte> The byte buffer to set as output data. SetOutput(string) Set the output data to be sent back to the host as a UTF-8 encoded string. public static void SetOutput(string data) Parameters data string The UTF-8 encoded string to set as output data. SetVar(string, MemoryBlock) Set a var that will be persisted by the host. public static void SetVar(string key, MemoryBlock value) Parameters key string value MemoryBlock SetVar(string, ReadOnlySpan<byte>) Set a variable value persisted by the host. public static void SetVar(string key, ReadOnlySpan<byte> bytes) Parameters key string The key for the persisted variable. bytes ReadOnlySpan<byte> The byte buffer to set as the variable value. SetVar(string, string) Set a variable value persisted by the host. public static void SetVar(string key, string value) Parameters key string The key for the persisted variable. value string A string value that will be UTF8 encoded. TryGetConfig(string, out string) Try to get a configuration value from the host. public static bool TryGetConfig(string key, out string value) Parameters key string The key for the configuration value. value string The retrieved configuration value as a string. Returns bool True if the configuration value was retrieved successfully; otherwise, false. TryGetVar(string, out MemoryBlock) Log a message with the specified log level to the host. public static bool TryGetVar(string key, out MemoryBlock block) Parameters key string The log level for the message. block MemoryBlock The log message as a string. Returns bool"
  },
  "api/Extism.html": {
    "href": "api/Extism.html",
    "title": "Namespace Extism | Extism .NET PDK",
    "keywords": "Namespace Extism Classes HttpRequest An HTTP request HttpResponse Response from an HTTP call MemoryBlock A block of allocated memory. Pdk Provides interop functions for communication between guests and the host. Enums HttpMethod HTTP Method LogLevel Log level"
  },
  "index.html": {
    "href": "index.html",
    "title": ".NET PDK | Extism .NET PDK",
    "keywords": ".NET PDK This library can be used to write Extism Plug-ins in C# and F#. NOTE: This is an experimental PDK. We'd love to hear your feedback. Prerequisites .NET SDK 8: https://dotnet.microsoft.com/en-us/download/dotnet/8.0 WASI Workload: dotnet workload install wasi-experimental WASI SDK: https://github.com/WebAssembly/wasi-sdk/releases Install Create a new project and add this nuget package to your project: dotnet new wasiconsole -o MyPlugin # OR, for F#: dotnet new console -o MyPlugin -lang F# cd MyPlugin dotnet add package Extism.Pdk --prerelease Update your MyPlugin.csproj/MyPlugin.fsproj as follows: <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier> <OutputType>Exe</OutputType> <PublishTrimmed>true</PublishTrimmed> <!-- Make sure we create a standalone wasm file for our plugin --> <WasmSingleFileBundle>true</WasmSingleFileBundle> <WasmBuildNative>true</WasmBuildNative> </PropertyGroup> </Project> Getting Started The goal of writing an Extism plug-in is to compile your C#/F# code to a Wasm module with exported functions that the host application can invoke. The first thing you should understand is creating an export. Let's write a simple program that exports a greet function which will take a name as a string and return a greeting string. Paste this into your Program.cs/Program.fs: C#: using System; using System.Runtime.InteropServices; using System.Text.Json; using Extism; namespace MyPlugin; public class Functions { public static void Main() { // Note: a `Main` method is required for the app to compile } [UnmanagedCallersOnly(EntryPoint = \"greet\")] public static int Greet() { var name = Pdk.GetInputString(); var greeting = $\"Hello, {name}!\"; Pdk.SetOutput(greeting); return 0; } } F#: module MyPlugin open System open System.Runtime.InteropServices open System.Text.Json open Extism [<UnmanagedCallersOnly(EntryPoint = \"greet\")>] let Greet () : int32 = let name = Pdk.GetInputString() let greeting = $\"Hello, {name}!\" Pdk.SetOutput(greeting) 0 [<EntryPoint>] let Main args = // Note: an `EntryPoint` function is required for the app to compile 0 Some things to note about this code: The [UnmanagedCallersOnly(EntryPoint = \"greet\")] is required, this marks the Greet function as an export with the name greet that can be called by the host. EntryPoint is optional. We need a Main but it's unused. If you do want to use it, it's exported as a function called _start. Exports in the .NET PDK are coded to the raw ABI. You get parameters from the host by calling Pdk.GetInput* functions and you send returns back with the Pdk.SetOutput functions. An Extism export expects an Int32 return code. 0 is success and 1 is a failure. Compile with this command: dotnet build This will create a MyPlugin.wasm file in bin/Debug/net8.0/wasi-wasm/AppBundle. Now, you can try out your plugin by using any of the Extism SDKs or by using Extism CLI's run command: extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm greet --input \"Benjamin\" --wasi # => Hello, Benjamin! Note: Currently wasi must be provided for all .NET plug-ins even if they don't need system access. More Exports: Error Handling Suppose we want to re-write our greeting function to never greet Benjamis. We can use Pdk.SetError: C#: [UnmanagedCallersOnly(EntryPoint = \"greet\")] public static int Greet() { var name = Pdk.GetInputString(); if (name == \"Benjamin\") { Pdk.SetError(\"Sorry, we don't greet Benjamins!\"); return 1; } var greeting = $\"Hello, {name}!\"; Pdk.SetOutput(greeting); return 0; } F#: [<UnmanagedCallersOnly(EntryPoint = \"greet\")>] let Greet () = let name = Pdk.GetInputString() if name = \"Benjamin\" then Pdk.SetError(\"Sorry, we don't greet Benjamins!\") 1 else let greeting = $\"Hello, {name}!\" Pdk.SetOutput(greeting) 0 Now when we try again: extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm greet --input=\"Benjamin\" --wasi # => Error: Sorry, we don't greet Benjamins! echo $? # print last status code # => 1 extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm greet --input=\"Zach\" --wasi # => Hello, Zach! echo $? # => 0 We can also throw a normal .NET Exception: var name = Pdk.GetInputString(); if (name == \"Benjamin\") { throw new ArgumentException(\"Sorry, we don't greet Benjamins!\"); } Now when we try again: extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm greet --input=\"Benjamin\" --wasi # => Error: System.ArgumentException: Sorry, we don't greet Benjamins! at MyPlugin.Functions.Greet() Json Extism export functions simply take bytes in and bytes out. Those can be whatever you want them to be. A common and simple way to get more complex types to and from the host is with json: C#: [JsonSerializable(typeof(Add))] [JsonSerializable(typeof(Sum))] public partial class SourceGenerationContext : JsonSerializerContext {} public record Add(int a, int b); public record Sum(int Result); public static class Functions { [UnmanagedCallersOnly] public static int add() { var inputJson = Pdk.GetInputString(); var parameters = JsonSerializer.Deserialize(inputJson, SourceGenerationContext.Default.Add); var sum = new Sum(parameters.a + parameters.b); var outputJson = JsonSerializer.Serialize(sum, SourceGenerationContext.Default.Sum); Pdk.SetOutput(outputJson); return 0; } } F#: [<UnmanagedCallersOnly>] let add () = let inputJson = Pdk.GetInputString() let jsonData = JsonDocument.Parse(inputJson).RootElement let a = jsonData.GetProperty(\"a\").GetInt32() let b = jsonData.GetProperty(\"b\").GetInt32() let result = a + b let outputJson = $\"{{ \\\"Result\\\": {result} }}\" Pdk.SetOutput(outputJson) 0 Note: For F#, please make sure the System.Text.Json NuGet package is installed in your project. extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm --wasi add --input='{\"a\": 20, \"b\": 21}' # => {\"Result\":41} Note: When enabling trimming, make sure you use the source generation as reflection is disabled in that mode. Configs Configs are key-value pairs that can be passed in by the host when creating a plug-in. These can be useful to statically configure the plug-in with some data that exists across every function call. Here is a trivial example using Pdk.TryGetConfig: C#: [UnmanagedCallersOnly(EntryPoint = \"greet\")] public static int Greet() { if (!Pdk.TryGetConfig(\"user\", out var user)) { throw new InvalidOperationException(\"This plug-in requires a 'user' key in the config\"); } var greeting = $\"Hello, {user}!\"; Pdk.SetOutput(greeting); return 0; } F#: [<UnmanagedCallersOnly(EntryPoint = \"greet\")>] let Greet () = match Pdk.TryGetConfig \"user\" with | true, user -> let greeting = $\"Hello, {user}!\" Pdk.SetOutput(greeting) 0 | false, _ -> failwith \"This plug-in requires a 'user' key in the config\" To test it, the Extism CLI has a --config option that lets you pass in key=value pairs: extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm --wasi greet --config user=Benjamin # => Hello, Benjamin! Variables Variables are another key-value mechanism but it's a mutable data store that will persist across function calls. These variables will persist as long as the host has loaded and not freed the plug-in. C#: [UnmanagedCallersOnly] public static int count() { int count = 0; if (Pdk.TryGetVar(\"count\", out var memoryBlock)) { count = BitConverter.ToInt32(memoryBlock.ReadBytes()); } count += 1; Pdk.SetVar(\"count\", BitConverter.GetBytes(count)); Pdk.SetOutput(count.ToString()); return 0; } F#: [<UnmanagedCallersOnly>] let count () = let count = match Pdk.TryGetVar \"count\" with | true, buffer -> BitConverter.ToInt32(buffer.ReadBytes()) | false, _ -> 0 let count = count + 1 Pdk.SetVar(\"count\", BitConverter.GetBytes(count)) Pdk.SetOutput(count.ToString()) 0 From Extism CLI: extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm --wasi count --loop 3 1 2 3 HTTP Sometimes it is useful to let a plug-in make HTTP calls: C#: [UnmanagedCallersOnly] public static int http_get() { // create an HTTP Request (withuot relying on WASI), set headers as needed var request = new HttpRequest(\"https://jsonplaceholder.typicode.com/todos/1\") { Method = HttpMethod.GET, }; request.Headers.Add(\"some-name\", \"some-value\"); request.Headers.Add(\"another\", \"again\"); var response = Pdk.SendRequest(request); Pdk.SetOutput(response.Body); return 0; } F#: [<UnmanagedCallersOnly>] let http_get () = let request = HttpRequest(\"https://jsonplaceholder.typicode.com/todos/1\") request.Headers.Add(\"some-name\", \"some-value\") request.Headers.Add(\"another\", \"again\") let response = Pdk.SendRequest(request) Pdk.SetOutput(response.Body) 0 From Extism CLI: extism call .\\bin\\Debug\\net8.0\\wasi-wasm\\AppBundle\\MyPlugin.wasm --wasi http_get --allow-host='*.typicode.com' { \"userId\": 1, \"id\": 1, \"title\": \"delectus aut autem\", \"completed\": false } NOTE: HttpClient doesn't work in Wasm yet. Imports (Host Functions) Like any other code module, Wasm not only let's you export functions to the outside world, you can import them too. Host Functions allow a plug-in to import functions defined in the host. For example, if you host application is written in Go, it can pass a Go function down to your Go plug-in where you can invoke it. This topic can get fairly complicated and we have not yet fully abstracted the Wasm knowledge you need to do this correctly. So we recommend reading our concept doc on Host Functions before you get started. A Simple Example Host functions have a similar interface as exports. You just need to declare them as extern on the top of your Program.cs/Program.fs. You only declare the interface as it is the host's responsibility to provide the implementation: C#: [DllImport(\"extism\", EntryPoint = \"a_go_func\")] public static extern ulong GoFunc(ulong offset); [UnmanagedCallersOnly] public static int hello_from_go() { var message = \"An argument to send to Go\"; using var block = Pdk.Allocate(message); var ptr = GoFunc(block.Offset); var response = MemoryBlock.Find(ptr).ReadString(); Pdk.SetOutput(response); return 0; } F#: [<DllImport(\"extism\", EntryPoint = \"a_go_func\")>] extern uint64 GoFunc(uint64 offset) [<UnmanagedCallersOnly>] let hello_from_go () = let message = \"An argument to send to Go\" use block = Pdk.Allocate(message) let ptr = GoFunc(block.Offset) let response = MemoryBlock.Find ptr Pdk.SetOutput(response) 0 Testing it out We can't really test this from the Extism CLI as something must provide the implementation. So let's write out the Go side here. Check out the docs for Host SDKs to implement a host function in a language of your choice. ctx := context.Background() config := extism.PluginConfig{ EnableWasi: true, } go_func := extism.NewHostFunctionWithStack( \"a_go_func\", func(ctx context.Context, p *extism.CurrentPlugin, stack []uint64) { input, err := p.ReadString(stack[0]) if err != nil { panic(err) } fmt.Println(\"Hello from Go!\") offs, err := p.WriteString(input + \"!\") if err != nil { panic(err) } stack[0] = offs }, []api.ValueType{api.ValueTypeI64}, []api.ValueType{api.ValueTypeI64}, ) Now when we load the plug-in we pass the host function: manifest := extism.Manifest{ Wasm: []extism.Wasm{ extism.WasmFile{ Path: \"/path/to/plugin.wasm\", }, }, } plugin, err := extism.NewPlugin(ctx, manifest, config, []extism.HostFunction{go_func}) if err != nil { fmt.Printf(\"Failed to initialize plugin: %v\\n\", err) os.Exit(1) } _, out, err := plugin.Call(\"hello_from_go\", []byte(\"Hello, World!\")) fmt.Println(string(out)) go run . # => Hello from Go! # => An argument to send to Go! Referenced Assemblies Methods in referenced assemblies that are decorated with [DllImport] and [UnmanagedCallersOnly] are imported and exported respectively. Note: The library imports/exports are ignored if the app doesn't call at least one method from the library. For example, if we have a library that contains this class: namespace MessagingBot.Pdk; public class Events { // This function will be imported by all WASI apps that reference this library [DllImport(\"env\", EntryPoint = \"send_message\")] public static extern void SendMessage(ulong offset); // You can wrap the imports in your own functions to make them easier to use public static void SendMessage(string message) { using var block = Extism.Pdk.Allocate(message); SendMessage(block.Offset); } // This function will be exported by all WASI apps that reference this library [UnmanagedCallersOnly] public static void message_received() { var message = Extism.Pdk.GetInputString(); // TODO: do stuff with message } } Then, we can reference the library in a WASI app and use the functions: using MessagingBot.Pdk; Events.SendMessage(\"Hello World!\"); This is useful when you want to provide a common set of imports and exports that are specific to your use case. Optimize Size Normally, the .NET runtime is very conservative when trimming and includes a lot of metadata for debugging and exception purposes. This makes sure code doesn't break (when using reflection for example) but it also means large binary sizes. A hello world sample is about 20mb. To instruct the .NET compiler to be aggresive about trimming, you can try out these options: <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier> <OutputType>Exe</OutputType> <PublishTrimmed>true</PublishTrimmed> <WasmBuildNative>true</WasmBuildNative> <WasmSingleFileBundle>true</WasmSingleFileBundle> <!-- Note: TrimMode Full breaks Extism's global exception handling hook --> <TrimMode>partial</TrimMode> <DebuggerSupport>false</DebuggerSupport> <EventSourceSupport>false</EventSourceSupport> <UseSystemResourceKeys>true</UseSystemResourceKeys> <NativeDebugSymbols>false</NativeDebugSymbols> </PropertyGroup> </Project> If you have imports in referenced assemblies, make sure you mark them as roots so that they don't get trimmed: <ItemGroup> <TrimmerRootAssembly Include=\"SampleLib\" /> </ItemGroup> And then, run: dotnet publish -c Release Now, you'll have a significantly smaller .wasm file in bin\\Release\\net8.0\\wasi-wasm\\AppBundle. For more details, refer to the official documentation. Reach Out! Have a question or just want to drop in and say hi? Hop on the Discord! API Docs Please see our API docs for detailed information on each type."
  }
}